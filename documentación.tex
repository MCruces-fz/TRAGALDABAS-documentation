\documentclass[a4paper]{book}
%\usepackage[subpreambles=true]{standalone}
\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
%\lstset { %
%%    language=C++,
%    backgroundcolor=\color{black!10}, % set backgroundcolor
%%    breaklines=true,
%%    frame=tlbr,
%    xleftmargin=0.5cm,
%    basicstyle=\ttfamily,
%    basicstyle=\footnotesize,% basic font setting
%}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C++,
  morekeywords={*, Int_t, UInt_t, Float_t, Bool_t, TMatrixF, TString, ClonesArray, TClonesArray}, 
  numbers=left,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  backgroundcolor=\color{yellow!10},
  identifierstyle=\color{black},
  stringstyle=\color{orange}\itfamily,
}

\lstdefinestyle{customsh}{
  language=bash,
  basicstyle=\color{green!60}\small\ttfamily,
  numbers=left,
  numberstyle=\color{black}\small\ttfamily,
  numbersep=3pt,
  frame=tb,
  showstringspaces=false,
  breaklines=true,
  columns=fullflexible,
  backgroundcolor=\color{black!85},
  linewidth=0.9\linewidth,
  xleftmargin=\parindent,  % 0.05\linewidth,
  xrightmargin=-0.1\linewidth
}

\usepackage{hyperref}
\usepackage{breakurl}

\let\vec\mathbf  % Bold vectors

\graphicspath{{images/}}

\usepackage[edges]{forest}
\definecolor{folderbg}{RGB}{124,166,198}
\definecolor{folderborder}{RGB}{110,144,169}
\newlength\Size
\setlength\Size{4pt}
\tikzset{%
  folder/.pic={%
    \filldraw [draw=folderborder, top color=folderbg!50, bottom color=folderbg] (-1.05*\Size,0.2\Size+5pt) rectangle ++(.75*\Size,-0.2\Size-5pt);
    \filldraw [draw=folderborder, top color=folderbg!50, bottom color=folderbg] (-1.15*\Size,-\Size) rectangle (1.15*\Size,\Size);
  },
  file/.pic={%
    \filldraw [draw=folderborder, top color=folderbg!5, bottom color=folderbg!10] (-\Size,.4*\Size+5pt) coordinate (a) |- (\Size,-1.2*\Size) coordinate (b) -- ++(0,1.6*\Size) coordinate (c) -- ++(-5pt,5pt) coordinate (d) -- cycle (d) |- (c) ;
  },
}
\forestset{%
  declare autowrapped toks={pic me}{},
  declare boolean register={pic root},
  pic root=0,
  pic dir tree/.style={%
    for tree={%
      folder,
      font=\ttfamily,
      grow'=0,
    },
    before typesetting nodes={%
      for tree={%
        edge label+/.option={pic me},
      },
      if pic root={
        tikz+={
          \pic at ([xshift=\Size].west) {folder};
        },
        align={l}
      }{},
    },
  },
  pic me set/.code n args=2{%
    \forestset{%
      #1/.style={%
        inner xsep=2\Size,
        pic me={pic {#2}},
      }
    }
  },
  pic me set={directory}{folder},
  pic me set={file}{file},
}



\begin{document}


\begin{titlepage}
	\par
	\centering
	\vspace{1cm}
	
\begin{minipage}[b]{0.5\linewidth}
\centering
	{\scshape\LARGE Users Manual}
	\vspace{40pt}
\end{minipage}
\begin{minipage}[b]{0.4\linewidth}
\includegraphics[height=8\baselineskip]{LogoUSC}
\end{minipage}

	\vspace{1.5cm}
	{\huge\bfseries TRAGALDABAS\\documentation\par}
	\vspace{0.25cm}
	
	\noindent\rule{\textwidth}{1pt}
	
	\vspace{0.25cm}
	{\huge\bfseries Hardware \& Software\par}
	
	\vspace{2cm}
	
	{\large\bfseries Instituto Galego de Altas Enerxías\par}
	\vspace{1cm}

%	Tutor:\par 
%	{\Large\itshape Alberto Pérez Muñuzuri\par}
%	{\small Grupo de Física no lineal \par (Dpto. Física de Partículas) \par }
%	\vspace{12pt}
%
%	Cotutor:\par 
%	{\Large\itshape David García Selfa\par}
%	{\small CESGA}\\
%	{\small (Centro de Supercomputación de Galicia)\par }
%	\vspace{12pt}
%	\vfill
%
%	Autor:\par
%	Miguel \textsc{Cruces}

	\vfill


	{\large \today\par}
\end{titlepage}


\thispagestyle{empty}
\vfill
\includegraphics[scale=0.25]{LogoIGFAE}


\tableofcontents

\chapter{Summary}
%\addcontentsline{toc}{chapter}{Summary}

\hspace{13pt} 


\chapter{Introduction}

%\addcontentsline{toc}{chapter}{Introduction}

\section{The Cosmic Rays}

At present, cosmic rays with large energies cannot be detected directly, so that we must measure the products of the atmospheric cascades of particles initiated by the incident astroparticle. In general, this cascades of secondary particles are generated by the inelastic nuclear collision between cosmic rays --those astroparticles-- and the atmospheric particles. Those secondary particles continue interacting and generating other and other secondary particles until a maximum is reached, and then the shower atenuates as far as more and more particles fall below the threshold for further particle production.

\section{The Detector}

Since 2014, in the LabCAF laboratory of the Faculty of Physics of the USC, a TRASGO type detector has been installed and taking data: TRAGALDABAS (TRAsGo for the AnaLysis of the nuclear matter Decay, the Atmosphere, the earth B-field And the Solar activity), with the intention of making a joint analysis of the data taken simultaneously with TRISTAN (TRasgo para InveSTigaciones ANtárticas), separated by a distance around $1.3 \times 10^7$ m.

This TRAGALDABAS detector is made of four planes of avalanche RCPs, but at the moment only three of them are instrumented yet. Those planes of 1.2$\times$1.5 m$^2$ are placed in a range of 1.8 m high and they are made up of 120 cells each one, placed in a 30$\times$40 array. Therefore, this device has an active area of 1.2$\times$1.5 m$^2$ and covers a vertical solid angle of $\sim $ 5 sr offering a time resolution of $\sim 300$ ps and track arriving angle resolution better than 3$^\circ$. 

\section{The Data Flow}

The detector is taking data with coincidence trigger between planes, at a rate about 7 million of registered events per day. This analog data of coincidences is converted to digital data and it is stored, along with humidity, pressure and temperature data.

For monitoring and alerting if data it is out of expected ranges, we use a software called Nagios. It is a software that provides great versatility to consult any parameter of interest in the system. The alerts generated are received by the corresponding managers (among other means) by email, when these parameters exceed the margins defined by the network administrator.

To format the numerical data and visualize it, we use Grafana. It is a platform without ani dependency and allows creating dashboards and graphs from multiple sources.

Both applications are multi-platform open-sources, licensed under the terms of the GNU General Public License and they are accessible from the computer called Trucha

\subsection{A PC Called Trucha}

It's name cames from the trout, that is a fish. In the LabCAF, the PCs (Pe-Ce-s in spanish, fishes in english) tower computers take names of fishes.

Actually, in this PC are stored the Nagios' warnings and alerts, and defined their ranges of activation. It looks like the directory tree of the Figure \ref{fg:directoryTree}.

To keep the code clean, readable, and manageable, each of the scripts in \texttt{/etc/nagios/scripts/} whose name begins with \texttt{sensor} parses the data from a single detector plane. Scripts that their name start with \texttt{check} call the classes defined in the previous ones for each of the functional detector planes.

Scripts in \texttt{/etc/nagios/objects/} are the configurations of the variables used for calling the later mentioned python scripts and where the limits of the alerts for Nagios are defined.



%\begin{figure}
%\begin{forest}
%  pic dir tree,
%  pic root,
%  for tree={directory,},
%	[/etc/nagios/
%		[...]
%		[..., file]
%		[scripts/
%			[check\_allAmbient.py, file]
%			[check\_allPower.py, file]
%			[check\_all.py, file]
%			[sensorHighVoltage\_tragaldabas.py, file]
%			[sensorHumidity\_tragaldabas.py, file]
%			[sensorPressure\_tragaldabas.py, file]
%			[sensorTemperature\_tragaldabas.py, file]
%		]
%		[objects/
%			[commands.cfg, file]
%			[contacts.cfg, file]
%			[hosts.cfg, file]
%			[printer.cfg, file]
%			[services.cfg, file]
%			[checkcommands.cfg, file]
%		]
%	]
%\end{forest}
%\label{fg:directoryTree}
%\caption{Directory tree of Trucha, where the programs for flow control are stored.}
%\end{figure}

...

\begin{figure}
\begin{forest}
  pic dir tree,
  pic root,
  for tree={directory,},
	[/media/Datos2TB/
		[tragaldabas/
			[data/
				[done/
				[... tryydddhhmmss.hld, file]
				]
				[Done -> done/]
				[matlab
				[... tryydddhhmmss\_TRBi.mat, file]
				]
				[sync
				[... tryydddhhmmss\_sync\_TRBi.mat, file]
				]		
			]
			[dst/]
			[external/]
			[git/]
			[historical\_data/]
			[luptab/]
			[scripts/]
		]
		[users]
		[...]
	]
\end{forest}
\label{fg:Datos2TBTree}
\caption{Directory tree of Trucha, inside the HDD with 2 TB of storage.}
\end{figure}





-----



\chapter{Unpacking data from TRAGALDABAS}

\section{DST\_Guide}

En el directorio \texttt{/media/Datos2TB/username/tragaldabas/soft\_TT/} tenemos los siguientes archivos, que se pueden ejecutar por este orden:

\begin{itemize}
	\item \textit{createFileLists.py}: Genera las listas con paths absolutos los archivos \textit{tryydddhhmmss.hld} tanto del \texttt{/media/Datos2TB/tragaldabas/data/done} como del \texttt{/media/externalHD/Tragaldabas/data\_hld} y los guarda en archivos \textit{list\_yyyy\_day\_ddd.list}, uno por cada día de archivos .hld. Además crea una carpeta con ellos y unas listas \textit{listExternal.list} con los nombres de los ficheros que ha encontrado en cada disco duro.
	
	\item \textit{efficiency.cc}: La ayuda para compilar este código se encuentra en \textit{howtocompile.txt}
	
	\begin{lstlisting}[style=customsh]
[username@fptrucha soft_TT]$ g++ -Wall -g -O -fPIC 'root-config --cflags' <filename.cc> 'root-config --glibs' 'root-config --libs' -L ./ -I ./ -ltunpacker -o <analysis_exe>
	\end{lstlisting}
	donde \textless filename.cc\textgreater\ es en este caso \textit{efficiency.cc} y en \textless analysis\_exe\textgreater\ se le da el nombre que se quiera al archivo ejecutable que crea con los parámetros del detector.
	
	Antes de proceder a la compilación, definir manualmente dentro de \textit{efficiency.cc} (o descomentar, si ya están escritas) solamente las siguientes líneas:
	
	\begin{lstlisting}[style=customc]
void doStaffCalibration(char* path,char* name){
	unpack.setFileLookupPar(<path_to_luptab>)
	// Escoger la luptab correspondiente a las fechas para las cuales se estan analizando estos datos concretos.
	unpack.setFileHitFinderPar(`empty_cal_2016.txt>`)
	// Estos datos son siempre los mismos.
	unpack.setFileHitFinderParOut(`<my_path>/20YYDST/pars/` + day + `_CalPars.txt`)
	// Aqui solamente introducir el path hacia tu directorio soft_TT.
	unpack.fillCalibration(`/media/Datos2TB/tragaldabas/data/done/`, `../` + fName, `../qcalhistos2/`, day + `\_qcalhistos.root`, 1000000, 0)
	// En esta linea, introducir correctamente los paths.
	}
	
void doStaffAnalysis(char* path,char* name){
	fill.setFileLookupPar(`luptabs/luptab.txt`)
	// Editar el path hacia la luptab correspondiente.
	fill.setFileHitFinderPath(`/day\_CalPars.txt`)
	// El output de unpack.setFileHitFinderParOut() sera el input de este metodo: introducir el path hacia el mismo.
	}
	
	/* 
	[...]
	*/
	\end{lstlisting}

	\item \textit{multiThreadRun.py}: Multiprocesado en varios cores para agilizar el proceso. Se lanza desde bash de la siguiente forma
	
	\begin{lstlisting}[style=customsh]
[username@fptrucha soft_TT]$ python3 multithreadRun.py ./analysis_exe lists_name.txt
	\end{lstlisting}
	siendo el primer argumento el nombre del archivo ejecutable devuelto por \textit{efficiency.cc} y el segundo el archivo con la lista de nombres devuelto por \textit{createFileLists.py}.
	
	\textbf{20XXDST/} new\_results.* para ver el root y en cuentas de celdas un valor de 2500 es razonable como máximo.
\end{itemize}

Al lanzar el ejecutable anterior, se generan archivos en los directorios \texttt{qcalhistos}\footnote{Histogramas de calibración} y \texttt{pars}, los cuales hay que crear manualmente junto a \texttt{../20YYDST/results}, donde \texttt{20YY} es el año.

``Matar celdas que hayan registrado ruído y volver a correr sobre los .hld''

\subsection{Proceso:}

(¿?) Primero creamos el archivo vacío de celdas activas con:
\begin{lstlisting}[style=customsh]
[username@fptrucha soft_TT]$ $ root -l CreateActiveCells.c
\end{lstlisting}
y a continuación
\begin{lstlisting}[style=customsh]
[username@fptrucha soft_TT]$ $ make clean
[username@fptrucha soft_TT]$ $ make
\end{lstlisting}

Blah blah

...

Crear directorio \texttt{20YYDST} manualmente en \texttt{/media/Datos2TB/username/} como se muestra en la figura \ref{fg:20YYDSTdir}

\begin{figure}[!h]
\begin{forest}
  pic dir tree,
  pic root,
  for tree={directory,},
	[/media/Datos2TB/username/
		[20YYDST/
			[qcalhistos/]
			[results/]
			[pars/]
		]
		[...]
		[..., file]
	]
\end{forest}
\label{fg:20YYDSTdir}
\caption{Directorio \texttt{20YYDST/} y subdirectorios.}
\end{figure}

A continuación, ejecutar los programas anteriormente mencionados. Notar que se pueden usar las flags:
\begin{itemize}
	\item \texttt{htop}: comando para ver procesos
	\item \texttt{root -l GoodActiveCells.root}: para abrir con \texttt{new TBrowser} más fácilmente (se queda arriba de todo en el árbol). Con esto se pueden ver las celdas muertas
	\item \texttt{hadd -f dst2018\_full.root *.root}: Une varios histogramas root (*.root) en un solo archivo (dst2038\_full.root).
\end{itemize}


Crear archivo vacio sin abrirlo
\begin{lstlisting}[style=customsh]
[username@fptrucha soft_TT]$ touch luptab.txt
[username@fptrucha soft_TT]$ ln -sf luptab\_20201013.txt luptab.txt
\end{lstlisting}
y crear un hard link\footnote{También llamado enlace simbólico.}. A continuación abrir \textit{efficiency.cc} y cambiar paths.

Exportar al load library path
\begin{lstlisting}[style=customsh]
[username@fptrucha any_dir]$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:<path/to/libtunpacker.so>
\end{lstlisting}
donde \texttt{<path/to/libtunpacker.so>} es el path absoluto al direcotrio \texttt{/media/.../ username/tragaldabas/soft\_TT/}


------


\chapter{Migración: \texttt{fpegaes2} $\rightarrow$ RaspBerry Pi \textgreater\ Nagios}

Para hacer la migración de los sensores de fpegaes2.usc.es a la Raspberry Pi 172.16.23.61, primero debemos familiarizarnos con las bases de datos RRD (Round Robin Database)\footnote{Nota: Dos o tres tablas relacionales, estructura para guardar datos con un número fijo de entradas.}. Una introducción a estas bases de datos se puede encontrar en:

\url{https://www.loriotpro.com/Products/On-line_Documentation_V5/LoriotProDoc_EN/V22-RRD_Collector_RRD_Manager/V22-A1_Introduction_RRD_EN.htm}

El funcionamiento de Nagios Graph y PNP4Nagios está en los siguientes links\footnote{Esto es lo menos crítico, porque en fpegaes2.usc.es se ve como está instalado el nagios graph y en fptrucha.usc.es está el PNP4Nagios (PNP4Nagios fuerza a tener una salida y hay que forzarlo (?).}

Nagiosgraph Manual Page:

\url{http://nagios.fm4dd.com/nagiosgraph/nagiosgraph-man.shtm}

PNP4Nagios Docs:

\url{http://docs.pnp4nagios.org/pnp-0.6/start}

(¿?) Buscar en fptrucha.usc.es los archivos python de cómo se accede a las bases de datos


\section{\texttt{fpegaes2}}

\subsection{Sensores}
Sensores en trucha \texttt{/etc/nagios/scripts/}

\subsection{Sample CGI Configuration File for Nagios 3.2.3}

\texttt{fptrucha.usc.es:/etc/nagios/cgi.cfg.fpegaes2}

\subsubsection{Main Configuration File}
This tells the CGIs where to find your main configuration file. The CGIs will read the main and host config files for any other data they might need.

\texttt{/etc/nagios/nagios.cgf}


\subsubsection{Physical HTML Path}
This is the path where the HTML files for Nagios reside.  This value is used to locate the logo images needed by the statusmap and statuswrl CGIs.

\texttt{/usr/share/nagios}


\subsubsection{URL HTML Path}
This is the path portion of the URL that corresponds to the physical location of the Nagios HTML files (as defined above). This value is used by the CGIs to locate the online documentation and graphics.  If you access the Nagios pages with an URL like
http://www.myhost.com/nagios, 
this value should be ``/nagios'' (without the quotes).

\texttt{/nagios}




\chapter{Software Documentation}



\section{The soft\_TT directory}

Inside of soft\_TT\footnote{Whose full path is \texttt{/media/Datos2TB/damian/tragaldabas/soft\_TT/}.} directory

tenemos las listas con los archivos.hld que da Tragaldabas como output. Por ejemplo list\_2019.list (que se abre con less en línea de comandos) tenemos una serie de archivos tr18234...hld

En soft\_TT/testlists/ hay listas con listas en su interior guardando más nombres de archivos.hld iguales. Estos definen cuáles interesan para ejecutar en cada una.

El archivo de python multiThreadRun.py en soft\_TT es el que ordena la ejecución en paralelo de los archivos.hld

\section{Classes definitions}

\subsection{TRpcHit}

TRpcHit is the class which does \textit{... that things ...}, and its source code is in the trpchit.cc and trpchit.h files. It has some protected variables:

\begin{itemize}
    \item Int\_t $fTrbnum$: Number of the TRB. Each plane has a TRB.
    \item Int\_t $fCell$: 
    \item Int\_t $fCol$: 
    \item Int\_t $fRow$: 
    \item Float\_t $fX$: X coordinate.
    \item Float\_t $fY$: Y coordinate.
    \item Float\_t $fZ$: Z coordinate.
    \item Float\_t $fTime$: Track time
    \item Float\_t $fCharge$: \textbf{Absolute} (¿?) value of the charge.
\end{itemize}

The methods of TRpcSaeta class are:

\subsubsection{getCell}

\begin{lstlisting}[style=customc]
Int_t getCell();
\end{lstlisting}

It returns the protected variable $fCell$.

\[\]

\subsubsection{getCharge}

\begin{lstlisting}[style=customc]
Int_t getCharge();
\end{lstlisting}

It returns the protected variable $fCharge$.

\[\]

\subsubsection{getCol}

\begin{lstlisting}[style=customc]
Int_t getCol();
\end{lstlisting}

It returns the protected variable $fCol$.

\[\]

\subsubsection{getHit}

\begin{lstlisting}[style=customc]
void getHit(Int_t& trbnum, Int_t& cell,Int_t&  col, Int_t&  row, Float_t& x, Float_t& y, Float_t& z, Float_t& time, Float_t& charge);
\end{lstlisting}

It sets the value of the protected variables passed as parameters to the respective variables stored in memory for the detector with two planes.

\begin{itemize}
	\item Int\_t $fTrbnum \rightarrow$ Int\_t $trbnum$
	\item Int\_t $fCell \rightarrow$ Int\_t $cell$
	\item Int\_t $fCol \rightarrow$ Int\_t $col$
	\item Int\_t $fRow \rightarrow$ Int\_t $row$
	\item Float\_t $fX \rightarrow$ Float\_t $x$
	\item Float\_t $fY \rightarrow$ Float\_t $y$
	\item Float\_t $fZ \rightarrow$ Float\_t $z$
	\item Float\_t $fTime \rightarrow$ Float\_t $time$
	\item Float\_t $fCharge \rightarrow$ Float\_t $charge$
\end{itemize}



\subsubsection{getRow}

\begin{lstlisting}[style=customc]
Int_t getRow();
\end{lstlisting}

It returns the protected variable $fRow$.

\[\]

\subsubsection{getTime}

\begin{lstlisting}[style=customc]
Int_t getTime();
\end{lstlisting}

It returns the protected variable $fTime$.

\[\]

\subsubsection{getTrbnum}

\begin{lstlisting}[style=customc]
Int_t getTrbnum();
\end{lstlisting}

It returns the protected variable $fTrbnum$.

\[\]

\subsubsection{getX}

\begin{lstlisting}[style=customc]
Int_t getX();
\end{lstlisting}

It returns the protected variable $fX$.

\[\]

\subsubsection{getY}

\begin{lstlisting}[style=customc]
Int_t getY();
\end{lstlisting}

It returns the protected variable $fY$.

\[\]

\subsubsection{getZ}

\begin{lstlisting}[style=customc]
Int_t getZ();
\end{lstlisting}

It returns the protected variable $fZ$.

\[\]

\subsubsection{setCell}

\begin{lstlisting}[style=customc]
void setCell(Int_t num );
\end{lstlisting}

It sets the value passed to the $num$ parameter to the protected variable $fCell$.

\[\]

\subsubsection{setCharge}

\begin{lstlisting}[style=customc]
void setCharge(Float_t val );
\end{lstlisting}

It sets the value passed to the $val$ parameter to the protected variable $fCharge$.

\[\]

\subsubsection{setCol}

\begin{lstlisting}[style=customc]
void setCol(Int_t num );
\end{lstlisting}

It sets the value passed to the $num$ parameter to the protected variable $fCol$.

\[\]

\subsubsection{setHit}

\begin{lstlisting}[style=customc]
void setHit(Int_t trbnum,Int_t  cell,Int_t  col,Int_t  row, Float_t x, Float_t y, Float_t z, Float_t time, Float_t charge);
\end{lstlisting}

It sets the value of the parameters to their respective protected variables.

\begin{itemize}
	\item Int\_t $trbnum \rightarrow$ Int\_t $fTrbnum$
	\item Int\_t $cell \rightarrow$ Int\_t $fCell$
	\item Int\_t $col \rightarrow$ Int\_t $fCol$
	\item Int\_t $row \rightarrow$ Int\_t $fRow$
	\item Float\_t $x \rightarrow$ Float\_t $fX$
	\item Float\_t $y \rightarrow$ Float\_t $fY$
	\item Float\_t $z \rightarrow$ Float\_t $fZ$
	\item Float\_t $time \rightarrow$ Float\_t $fTime$
	\item Float\_t $charge \rightarrow$ Float\_t $fCharge$
\end{itemize}

\subsubsection{setRow}

\begin{lstlisting}[style=customc]
void setRow(Int_t num );
\end{lstlisting}

It sets the value passed to the $num$ parameter to the protected variable $fRow$.

\[\]

\subsubsection{setTime}

\begin{lstlisting}[style=customc]
void setTime(Float_t val );
\end{lstlisting}

It sets the value passed to the $val$ parameter to the protected variable $fTime$.

\[\]

\subsubsection{setTrbnum}

\begin{lstlisting}[style=customc]
void setTrbnum(Int_t num );
\end{lstlisting}

It sets the value passed to the $num$ parameter to the protected variable $fTrbnum$.

\[\]

\subsubsection{setX}

\begin{lstlisting}[style=customc]
void setX(Float_t val );
\end{lstlisting}

It sets the value passed to the $val$ parameter to the protected variable $fX$.

\[\]

\subsubsection{setY}

\begin{lstlisting}[style=customc]
void setY(Float_t val );
\end{lstlisting}

It sets the value passed to the $val$ parameter to the protected variable $fY$.

\[\]

\subsubsection{setZ}

\begin{lstlisting}[style=customc]
void setZ(Float_t val );
\end{lstlisting}

It sets the value passed to the $val$ parameter to the protected variable $fZ$.

\[\]

\subsection{TRpcHitF}

TRpcHitF is the class which does \textit{... that things ...}, and its source code is in the trpchitf.cc and trpchitf.h files. It has some private variables:

\begin{itemize}
    \item TRpcCalPar *$fPar$: 
    \item TClonesArray *$fRpcRawHits$: 
    \item TClonesArray *$fRpcHitHits$: 
    \item TActiveCells *$fActiveCells$: 
    \item Int\_t $totalNHits$: 
\end{itemize}

The methods of TRpcHitF class are:

\subsubsection{addRpcHit}

\begin{lstlisting}[style=customc]
TRpcHit* addRpcHit();
\end{lstlisting}

It returns the pointer to a new \texttt{(hits[totalNHits++]) TRpcHit()}.

\[\]

\subsubsection{execute}

IDK [...]

\[\]

\subsubsection{init}

\begin{lstlisting}[style=customc]
Int_t init(TString filename, TString filenameActive);
\end{lstlisting}

It creates a new TRpcCalPar object called $fPar$ with name $filename$ and another new TActiveCells object called $fActiveCells$ with name $filenameActive$. Then takes \texttt{gEvent -> getRpcRawHits()} and stores it in the private variable $fRpcRawHits$.

\[\]

\subsubsection{getRpcHits}

\begin{lstlisting}[style=customc]
TClonesArray*  getRpcHits();
\end{lstlisting}

It returns the private variable $fRpcHitHits$.

\[\]

\subsubsection{getRpcRawHits}

\begin{lstlisting}[style=customc]
TClonesArray*  getRpcRawHits();
\end{lstlisting}

It returns \texttt{gEvent->getRpcRawHits()}.

\[\]

\subsection{TRpcSaeta}

TRpcSaeta is the class which does \textit{... that things ...}, and its source code is in the trpcsaeta.cc and trpcsaeta.h files. All its initial values are set as $-1$ with the constructor. It has some protected variables:

\begin{itemize}
	\item Float\_t $fX$: X coordinate.
	\item Float\_t $fXP$: X slope.
	\item Float\_t $fY$: Y coordinate.
	\item Float\_t $fYP$: Y slope.
	\item Float\_t $fZ$: Z coordinate.
	\item Float\_t $fTime$: Track time.
	\item Float\_t $fSlow$: Slowness.
	\item Float\_t $fAl$: Alpha angle.
	\item Float\_t $fBe$: Beta angle.
	\item Float\_t $fGa$: Gamma angle.
	\item Int\_t   $fSaN$: Saeta order.
	\item Int\_t   $find0$: Hit index.
	\item Int\_t   $find1$: Hit index.
	\item Int\_t   $find2$: Hit index.
	\item Float\_t $fChi2$: Chi-square.
\end{itemize}

The methods of TRpcSaeta class are:

\subsubsection{getAl}

\begin{lstlisting}[style=customc]
Float_t getAl();
\end{lstlisting}

It returns the alpha $\alpha$ angle in radians $fAl$. This is the angle between the trayectory of the incident particle and the $x$-axis.

\[\]

\subsubsection{getBe}

\begin{lstlisting}[style=customc]
Float_t getBe();
\end{lstlisting}

It returns the beta $\beta$ angle in radians $fBe$. This is the angle between the trayectory of the incident particle and the $y$-axis.

\[\]

\subsubsection{getChi2}

\begin{lstlisting}[style=customc]
Float_t getChi2();
\end{lstlisting}

It returns the chi squared $\chi^2$ value $fChi2$.

\[\]

\subsubsection{getGa}

\begin{lstlisting}[style=customc]
Float_t getGa();
\end{lstlisting}

It returns the gamma $\gamma$ angle in radians $fGa$w. This is the angle between the trayectory of the incident particle and the $z$-axis.

\[\]

\subsubsection{getInd}

\begin{lstlisting}[style=customc]
Int_t getInd(Int_t n);
\end{lstlisting}

It returns the hit index for the $n$ parameter:
\begin{itemize}
	\item $n = 0 \rightarrow find0$
	\item $n = 1 \rightarrow find1$
	\item $n = 2 \rightarrow find2$
\end{itemize}

If $n \neq 0, 1, 2$, it returns $-1$.

\[\]

\subsubsection{getPhi}

\begin{lstlisting}[style=customc]
Float_t getPhi();
\end{lstlisting}

It returns the phi $\phi$ angle. This is the principal value of the arc tangent of $fAl/fBe$, expressed in radians.

\[\]

\subsubsection{getPhiDeg}

\begin{lstlisting}[style=customc]
Float_t getPhiDeg();
\end{lstlisting}

It returns the phi $\phi$ angle in degrees. This is the principal value of the arc tangent of $fAl/fBe$.

\[\]

\subsubsection{getRpcSaeta2Planes}

\begin{lstlisting}[style=customc]
void getRpcSaeta2Planes(Float_t& x0,Float_t& y0,Float_t& t0, Float_t& al,Float_t& be,Float_t& ga,Int_t& ind0, Int_t& ind1);
\end{lstlisting}

It sets the value of the protected variables passed as parameters to the respective variables stored in memory for the detector with two planes.

\begin{itemize}
	\item Float\_t $fX0 \rightarrow$ Float\_t $x0$
	\item Float\_t $fY0 \rightarrow$ Float\_t $y0$
	\item Float\_t $fTime \rightarrow$ Float\_t $t0$
	\item Float\_t $fAl \rightarrow$ Float\_t $al$
	\item Float\_t $fBe \rightarrow$ Float\_t $be$
	\item Float\_t $fGa \rightarrow$ Float\_t $ga$
	\item Int\_t $find0 \rightarrow$ Int\_t $ind0$
	\item Int\_t $find1 \rightarrow$ Int\_t $ind1$
\end{itemize}

\subsubsection{getRpcSaeta3Planes}

\begin{lstlisting}[style=customc]
void getRpcSaeta3Planes(Float_t& x0,Float_t& xP,Float_t& y0, Float_t& yP,Float_t& z, Float_t& t0,Float_t& sl, Float_t& al, Float_t& be,Float_t& ga, Int_t& san, Int_t& ind0,Int_t& ind1, Int_t& ind2, Float_t& chi2);
\end{lstlisting}

It sets the value of the protected variables passed as parameters to the respective variables stored in memory for the detector with three planes.

\begin{itemize}
	\item Float\_t $fX0 \rightarrow$ Float\_t $x0$
	\item Float\_t $fXP \rightarrow$ Float\_t $xP$
	\item Float\_t $fY0 \rightarrow$ Float\_t $y0$
	\item Float\_t $fYP \rightarrow$ Float\_t $yP$
	\item Float\_t $fZ \rightarrow$ Float\_t $z$
	\item Float\_t $fTime \rightarrow$ Float\_t $t0$
	\item Float\_t $fSlow \rightarrow$ Float\_t $sl$
	\item Float\_t $fAl \rightarrow$ Float\_t $al$
	\item Float\_t $fBe \rightarrow$ Float\_t $b$
	\item Float\_t $fGa \rightarrow$ Float\_t $ga$
	\item Float\_t $fSaN \rightarrow$ Float\_t $san$
	\item Int\_t $find0 \rightarrow$ Int\_t $ind0$
	\item Int\_t $find1 \rightarrow$ Int\_t $ind1$
	\item Int\_t $find2 \rightarrow$ Int\_t $ind2$
	\item Int\_t $fChi2 \rightarrow$ Int\_t $chi2$
\end{itemize}

\subsubsection{getSaetaN}

\begin{lstlisting}[style=customc]
Float_t getSaetaN();
\end{lstlisting}

It returns the value of the saeta order $fSaN$.

\[\]

\subsubsection{getSlow}

\begin{lstlisting}[style=customc]
Float_t getX0();
\end{lstlisting}

It returns the slownes of the particle $fSlow$, which is the inverse of velocity $1/v$ (Units?).

\[\]

\subsubsection{getTheta}

\begin{lstlisting}[style=customc]
Float_t getTheta();
\end{lstlisting}

It returns the theta $\theta$ angle. This is the principal value of the arc cosine of $fGa$, expressed in radians.

\[\]

\subsubsection{getThetaDeg}

\begin{lstlisting}[style=customc]
Float_t getThetaDeg();
\end{lstlisting}

It returns the theta $\theta$ angle in degrees. This is the principal value of the arc cosine of $fGa$.

\[\]

\subsubsection{getTime}

\begin{lstlisting}[style=customc]
Float_t getTime();
\end{lstlisting}

It returns the time of the hit measured since the tracking started (Units?) $fTime$.

\[\]


\subsubsection{getX0}

\begin{lstlisting}[style=customc]
Float_t getX0();
\end{lstlisting}

It returns the X coorinate, $fX$ (Units?).

\[\]

\subsubsection{getXP}

\begin{lstlisting}[style=customc]
Float_t getXP();
\end{lstlisting}

It returns the X slope, $fXP$ (Units?).

\[\]

\subsubsection{getY0}

\begin{lstlisting}[style=customc]
Float_t getY0();
\end{lstlisting}

It returns the Y coorinate, $fY$ (Units?).

\[\]

\subsubsection{getYP}

\begin{lstlisting}[style=customc]
Float_t getYP();
\end{lstlisting}

It returns the Y slope, $fYP$ (Units?).

\[\]

\subsubsection{getZ0}

\begin{lstlisting}[style=customc]
Float_t getZ0();
\end{lstlisting}

It returns the Z coorinate, $fZ$ (Units?).

\[\]

\subsubsection{setRpcSaeta2Planes}

\begin{lstlisting}[style=customc]
void setRpcSaeta2Planes(Float_t x0,Float_t y0,Float_t t0, Float_t al,Float_t be,Float_t ga,Int_t ind0,Int_t ind1);
\end{lstlisting}

It sets the value of the parameters to their respective protected variables for the detector with only two planes.

\begin{itemize}
	\item Float\_t $x0 \rightarrow$ Float\_t $fX0$
	\item Float\_t $y0 \rightarrow$ Float\_t $fY0$
	\item Float\_t $t0 \rightarrow$ Float\_t $fTime$
	\item Float\_t $al \rightarrow$ Float\_t $fAl$
	\item Float\_t $be \rightarrow$ Float\_t $fBe$
	\item Float\_t $ga \rightarrow$ Float\_t $fGa$
	\item Int\_t $ind0 \rightarrow$ Int\_t $find0$
	\item Int\_t $ind1 \rightarrow$ Int\_t $find1$
\end{itemize}

\subsubsection{setRpcSaeta3Planes}

\begin{lstlisting}[style=customc]
void setRpcSaeta3Planes(Float_t x0,Float_t xP,Float_t y0, Float_t yP,Float_t z, Float_t t0,Float_t sl, Float_t al, Float_t be,Float_t ga, Int_t san,Int_t ind0,Int_t ind1, Int_t ind2, Float_t chi2);
\end{lstlisting}

It sets the value of the parameters to their respective protected variables for the detector with three planes.

\begin{itemize}
	\item Float\_t $x0 \rightarrow$ Float\_t $fX0$
	\item Float\_t $xP \rightarrow$ Float\_t $fXP$
	\item Float\_t $y0 \rightarrow$ Float\_t $fY0$
	\item Float\_t $yP \rightarrow$ Float\_t $fYP$
	\item Float\_t $z \rightarrow$ Float\_t $fZ$
	\item Float\_t $t0 \rightarrow$ Float\_t $fTime$
	\item Float\_t $sl \rightarrow$ Float\_t $fSlow$
	\item Float\_t $al \rightarrow$ Float\_t $fAl$
	\item Float\_t $be \rightarrow$ Float\_t $fBe$
	\item Float\_t $ga \rightarrow$ Float\_t $fGa$
	\item Float\_t $san \rightarrow$ Float\_t $fSaN$
	\item Int\_t $ind0 \rightarrow$ Int\_t $find0$
	\item Int\_t $ind1 \rightarrow$ Int\_t $find1$
	\item Int\_t $ind2 \rightarrow$ Int\_t $find2$
	\item Int\_t $chi2 \rightarrow$ Int\_t $fChi2$
\end{itemize}

\subsubsection{setTime}

\begin{lstlisting}[style=customc]
void setTime(Float_t val);
\end{lstlisting}

It sets the value of the parameter $val$ to the protected variable $fTime$.

\[\]




\subsection{TRpcSaetaF}

TRpcSaetaF is the class which does \textit{... that things ...}, and its source code is in the trpcsaetaf.cc and trpcsaetaf.h files. It has some protected variables:

\begin{itemize}
	\item TClonesArray  *$fRpcHitHits$: 
	\item TClonesArray  *$fRpcHitCorr$: 
	\item TClonesArray  *$fRpcSaeta2Planes$: 
	\item TClonesArray  *$fRpcSaeta3Planes$: 
	\item Int\_t \textit{totalNHits}: 
	\item Int\_t \textit{totalNHits}2\textit{Planes}: 
	\item Int\_t \textit{totalNHits}3\textit{Planes}: 
	\item Int\_t \textit{totalNHitsCorr}: 
\end{itemize}

And it also has other public variables:

\begin{itemize}
	\item TMatrixF $InputSaeta2Planes$: the saeta vector with next values as arguments
	
	\begin{lstlisting}[style=customc]
TMatrixF InputSaeta2Planes(Float_t x1, Float_t y1, Float_t t1, Float_t z1, Float_t x2, Float_t y2, Float_t t2, Float_t z2);
	\end{lstlisting}
	
	where $(x_1, y_1, z_1, t_1)$ are the coordinates in the first plane and $(x_2, y_2, z_2, t_2)$ in the second one
	
%	\begin{itemize}
%		\item Float\_t $x_1$: 
%		\item Float\_t $y_1$: 
%		\item Float\_t $t_1$: 
%		\item Float\_t $z_1$: 
%		\item Float\_t $x_2$: 
%		\item Float\_t $y_2$: 
%		\item Float\_t $t_2$: 
%		\item Float\_t $z_2$: 
%	\end{itemize}
	
	\begin{align*}
%	InputSaeta2Planes \equiv \vec{S} = [ (x2*z1-x1*z2)/Dz,\\
%	 (x1-x2)/Dz, \\
%	 (y2*z1-y1*z2)/Dz, \\
%	 (y1-y2)/Dz, \\
%	 (t2*z1-t1*z2)/Dz, \\
%	 (t1-t2)/Dz ],
	InputSaeta2Planes = \left(
	\begin{array}{c}
	 \dfrac{x_2 z_1-x_1 z_2}{Dz}\\
%	 (x_2 z_1-x_1 z_2)/Dz\\
	 \dfrac{x_1-x_2}{Dz} \\
%	 (x_1-x_2)/Dz \\
	 \dfrac{y_2 z_1-y_1 z_2}{Dz} \\
%	 (y_2 z_1-y_1 z_2)/Dz \\
	 \dfrac{y_1-y_2}{Dz} \\
%	 (y_1-y_2)/Dz \\
	 \dfrac{t_2 z_1-t_1 z_2}{Dz} \\
%	 (t_2 z_1-t_1 z_2)/Dz \\
	 \dfrac{t_1-t_2}{Dz}
%	 (t_1-t_2)/Dz
	\end{array} \right),
	\end{align*}
	and where Float\_t $Dz = z1 - z2$. So that,
	
	\begin{equation}
	\notag
	InputSaeta2Planes \equiv \vec{S} = (x_0, x_p, y_0, y_p, t_0, s_0)
	\end{equation}
	is the saeta vector in the parameters space represented with respect to the origin of coordinates.
	
	
	\item TMatrixF $KMatrix$: the $K$ matrix with next values as arguments
	
	\begin{lstlisting}[style=customc]
TMatrixF KMatrix(TMatrixF SIn, Float_t z);
	\end{lstlisting}
	
	where $SIn$ is the input saeta vector
	
	\begin{align*}
	SIn = \left(
	\begin{array}{c}
	x_0\\
	x_p\\
	y_0\\
	y_p\\
	t_0\\
	s_0
	\end{array} \right),
	\end{align*}
	
	and $z$ the height of the current plane. The $k$ value is
	
	\begin{equation}
	\notag
	k = \sqrt{1 + x_p^2 + y_p^2},
	\end{equation}
	
	so that, $KMatrix$ is
	
	\begin{align*}
%	KMatrix =
	\left(
	\begin{array}{cccccc}
	w_x   & w_x z & 0 & 0 & 0 & 0\\
	w_x z & w_x z^2 + s_0^2 w_t x_p^2 z^2/k^2 & 0 & s_0^2 w_t x_p^2 z^2 /k^2 & s_0 w_t x_p z/k & s_0 w_t y_p z^2 \\
	0 & 0 & w_y & w_y z & 0 & 0\\
	0 & s_0^2 w_t x_p^2 z^2 /k^2 & w_y z & w_y z^2 + s_0^2 w_t x_p^2 z^2/k^2 & s_0 w_t y_p z/k & s_0 w_t y_p z^2\\
	0 & s_0 w_t x_p z/k & 0 & s_0 w_t y_p z/k & w_t & w_t k z\\
	0 & s_0 w_t y_p z^2 & 0 & s_0 w_t y_p z^2 & w_t k z & w_t k^2 z^2
	\end{array} \right)
	\end{align*}
	
	\item TMatrixF $AVector$: constructs the \textbf{measurement} (¿?) vector for a non-linear model with next values as arguments
	
	\begin{lstlisting}[style=customc]
TMatrixF AVector(TMatrixF SIn, Float_t x, Float_t y, Float_t t, Float_t z);
	\end{lstlisting}
	
	where $(x, y, z, t)$ are the measured coordinates and $SIn$ and $k$ have the same form as in TMatrixF $KMatrix$. So $AVector$ is
	
	\begin{align*}
	AVector = \left(
	\begin{array}{c}
	w_x x\\
	z \dfrac{w_x x k^2 + s_0 w_t x_p (t k+ s_0 (x_p^2 +y_p^2 )z)}{k^2}\\
	w_y y\\
	z \dfrac{w_y y k^2 + s_0 w_t y_p (t k+ s_0 (x_p^2 +y_p^2 )z)}{k^2}\\
	w_t \dfrac{t k + s_0 (x_p^2+ y_p^2)z}{k}\\
	w_t (t k + s_0 (x_p^2+ y_p^2)z) z
	\end{array} \right).
	\end{align*}
	
	
\end{itemize}

\[\]

The methods of TRpcSaetaF class are:

\subsubsection{addRpcHit}

\begin{lstlisting}[style=customc]
TRpcHit* addRpcHit();
\end{lstlisting}

It returns the pointer $rpchit$, which points to a new \texttt{(hits[totalNHitsCorr++]) TRpcHit()}, the next hit.

\[\]

\subsubsection{addRpcSaeta2Planes}

\begin{lstlisting}[style=customc]
TRpcSaeta* addRpcSaeta2Planes();
\end{lstlisting}

It returns the pointer $RpcSaeta$, which points to a new \texttt{(RpcSaeta2Planes} \texttt{[totalNHits2Planes++])} \texttt{TRpcSaeta()}, the next [...].

\[\]

\subsubsection{addRpcSaeta3Planes}

\begin{lstlisting}[style=customc]
TRpcSaeta* addRpcSaeta3Planes()
\end{lstlisting}

It returns the pointer $RpcSaeta$, which points to a new \texttt{(RpcSaeta3Planes} \texttt{[totalNHits3Planes++])} \texttt{TRpcSaeta()}, the next [...].

\[\]

\subsubsection{execute}

\begin{lstlisting}[style=customc]
Int_t execute();
\end{lstlisting}

The main function of the class. It makes the loops for finding hits in planes and stores them on Ttrees.

\[\]

\subsubsection{getRpcHits}

\begin{lstlisting}[style=customc]
TClonesArray* getRpcHits() {return gEvent->getRpcHits(); }
\end{lstlisting}

[...]

\[\]

\subsubsection{getRpcHitsCorr}

\begin{lstlisting}[style=customc]
ClonesArray* getRpcHitCorr() {return fRpcHitCorr; }
\end{lstlisting}

[...]

\[\]

\subsubsection{getRpcSaeta2Planes}

\begin{lstlisting}[style=customc]
ClonesArray* getRpcSaeta2Planes() {return fRpcSaeta2Planes; }
\end{lstlisting}

It returns the private $fRpcSaeta2Planes$ pointer.

\[\]

\subsubsection{getRpcSaeta3Planes}

\begin{lstlisting}[style=customc]
ClonesArray* getRpcSaeta3Planes() {return fRpcSaeta3Planes; }
\end{lstlisting}

It returns the private $fRpcSaeta3Planes$ pointer.

\[\]

\subsubsection{init}

\begin{lstlisting}[style=customc]
Int_t init();
\end{lstlisting}

It initializes the variables $fRpcHitCorr$, $fRpcSaeta2Planes$ and $fRpcSaeta3Planes$ if they are not defined by TClonesArray, creating the new ones.

\[\]

\subsection{TTMatrix}

TTMatrix is the class which does \textit{... that things ...}, and its source code is in the ttmatrix.cc and ttmatrix.h files. It has some protected variables:

\begin{itemize}
	\item Float\_t $fX1$: X coordinate in the first plane
	\item Float\_t $fY1$: Y coordinate in the first plane
	\item Float\_t $fT1$: time in the first plane
	\item Float\_t $fZ1$: Z coordinate in the first plane
	\item Float\_t $fX2$: X coordinate in the second plane
	\item Float\_t $fY2$: Y coordinate in the second plane
	\item Float\_t $fT2$: time in the second plane
	\item Float\_t $fZ2$: Z coordinate in the second plane
	\item Float\_t $fwx$: deviation of cell shape in x direction
	\item Float\_t $fwy$: deviation of cell shape in y direction
	\item Float\_t $fwz$: EN TEORÍA NO HAY INCERTIDUMBRE EN Z
\end{itemize}

And it also has other public variables:

\begin{itemize}
	\item TMatrixF $AVector$: is the vector which \textit{... do things ...} ¿Is it the \textbf{measurement} vector?
	\begin{lstlisting}[style=customc]
TMatrixF AVector(TMatrixF SIn, Float_t x, Float_t y, Float_t t, Float_t z);
	\end{lstlisting}

	where $SIn$ is the input saeta vector

	\begin{align*}
	SIn = \left(
	\begin{array}{c}
	x_0\\
	x_p\\
	y_0\\
	y_p\\
	t_0\\
	s_0
	\end{array} \right),
	\end{align*}
	
	and $(x, y, z, t)$ the measured coordinates and time. The $k$ value is 
	
	\begin{equation}
	\notag
	k = \sqrt{1 + x_p^2 + y_p^2},
	\end{equation}
	
	so that, $AVector$ is
	
	\begin{align*}
	AVector = \left(
	\begin{array}{c}
	w_x x\\
	z \dfrac{w_x x k^2 + s_0 w_t x_p (t k + s_0 (x_p^2 + y_p^2) z)}{k^2}\\
	w_y y\\
	z \dfrac{w_y y k^2 + s_0 w_t y_p (t k + s_0 (x_p + y_p) z)}{k^2}\\
	w_t \dfrac{t k + s_0 (x_p + y_p) z}{k}\\
	w_t z (t k + s_0 (x_p + y_p) z)
	\end{array} \right).
	\end{align*}
	
	Here the $w_x, w_y, w_z, w_t$ variables are initializated to zero all of them when $AVector$ is created.
	
	\item TMatrixF $KMatrix$: is the vector which \textit{... do things ...} ¿Is it the \textbf{measurement} vector?
	\begin{lstlisting}[style=customc]
TMatrixF KMatrix(TMatrixF SIn, Float_t z);
	\end{lstlisting}

	where $SIn$ is the input saeta vector

	\begin{align*}
	SIn = \left(
	\begin{array}{c}
	x_0\\
	x_p\\
	y_0\\
	y_p\\
	t_0\\
	s_0
	\end{array} \right),
	\end{align*}
	
	and $(x, y, z, t)$ the measured coordinates and time. The $k$ value has the same shape as in the $AVector$. So, the $KMatrix$ is
	
	\begin{align*}
%	KMatrix =
	\left(
	\begin{array}{cccccc}
	w_x   & w_x z                             & 0     & 0                        & 0               & 0\\
	w_x z & w_x z^2 + s_0^2 w_t x_p^2 z^2/k^2 & 0     & s_0^2 w_t x_p^2 z^2 /k^2 & s_0 w_t x_p z/k & s_0 w_t y_p z^2 \\
	0     & 0                                 & w_y   & w_y z                    & 0               & 0\\
	0     & s_0^2 w_t x_p^2 z^2 /k^2          & w_y z & w_y z^2 + s_0^2 w_t x_p^2 z^2/k^2 & s_0 w_t y_p z/k & s_0 w_t y_p z^2\\
	0     & s_0 w_t x_p z/k                   & 0     & s_0 w_t y_p z/k          & w_t             & w_t k z\\
	0     & s_0 w_t y_p z^2                   & 0     & s_0 w_t y_p z^2          & w_t k z         & w_t k^2 z^2
	\end{array} \right),
	\end{align*}
	
	with $w_x, w_y, w_z, w_t$ initializated as zero.
	
	\item TMatrixF \textit{InputSaeta2Planes}:  the saeta vector with next values as arguments
	
	\begin{lstlisting}[style=customc]
TMatrixF InputSaeta2Planes(Float_t x1, Float_t y1, Float_t t1, Float_t z1, Float_t x2, Float_t y2, Float_t t2, Float_t z2);
	\end{lstlisting}
	
	where $x_1, y_1, z_1, t_1$ are the coordinates in the first plane and $x_2, y_2, z_2, t_2$ in the second one. This is a function that returns
	
	\begin{align*}
	InputSaeta2Planes = \left(
	\begin{array}{c}
	 \dfrac{x_2 z_1-x_1 z_2}{z_1 - z_2}\\ \\
	 \dfrac{x_1-x_2}{z_1 - z_2} \\ \\
	 \dfrac{y_2 z_1-y_1 z_2}{z_1 - z_2} \\ \\
	 \dfrac{y_1-y_2}{z_1 - z_2} \\ \\
	 \dfrac{t_2 z_1-t_1 z_2}{z_1 - z_2} \\ \\
	 \dfrac{t_1-t_2}{z_1 - z_2}
	\end{array} \right),
	\end{align*}
	
	and assigns the parameters $x_1, y_1, z_1, t_1, x_2, y_2, z_2, t_2$ to the protected variables of the calss $fX1 , fY1, fZ1, fT1, fX2, fY2, fZ2, fT2$ respectively.
	
\end{itemize}

\subsection{Unpacker}

Unpacker is the class which does \textit{... that things ...}, and its source code is in the trpcunpacker.cc and trpcunpacker.h files.



Unpacker has some protected variables:

\begin{itemize}
	\item HldEvent* $pEvent$: current event read from file.
    \item Int\_t $EventNr$: event Counter.
    \item Int\_t $EventLimit$: maximum event number per file.
    \item Int\_t $subEvtId$:
    \item TFile* $pRootFile$: pointer to TFile with the output tree.
    \item std::string $inputFile$: wk 28.05
    \item std::string $outputFile$: wk 28.05
    \item Int\_t \textit{fpga\_code}: address of the data source (e.g. given fpga ) decoded from hld file.
    \item Int\_t $refCh$: 
\end{itemize}



\subsubsection{* The Constructors}

\begin{lstlisting}[style=customc]
Unpacker(const char* dir,const char* name, const char* odir, Int_t nEvt, TString luptab, TString calpar);
\end{lstlisting}

Using this construtor of unpacker we have access the data output of the tracking code. By executing this code into the \textsc{root} command line we can check whether or not what we rebuild is compatible with the current methods. Parameters:

\begin{itemize}
	\item const char* $dir$: Directory of input data, which is the output of Tragaldabas.
	\item const char* $name$: Name of the file to unpack, (i. e. \texttt{tr18249041152.hld}.)
	\item const char* $odir$: Output directory, here will appear the unpacked files.
	\item Int\_t $nEvt$: Number of events (i. e. 1000).
	\item TString $luptab$: Name of the luptable txt file (i. e. \texttt{luptable\_corr\_20180423.txt}).
	\item TString $calpar$: Name of the CalPar txt file (i. e. \texttt{2018\_day\_203\_CalPars.txt}).
\end{itemize}

\[\]

The methods of the Unpacker class are:

\subsubsection{eventLoop}

\begin{lstlisting}[style=customc]
Bool_t eventLoop(Int_t NbEvt=50000,Int_t startEvt=0);
\end{lstlisting}

Loop over all events, data is written to the root tree.

\begin{itemize}
	\item Int\_t $NbEvt$: 
	\item Int\_t $startEvt$: 
\end{itemize}

\subsubsection{eventLoopFillCal}

\begin{lstlisting}[style=customc]
Bool_t eventLoopFillCal(Int_t nbEvt, Int_t startEv, TH1D** hq, TH1D** hdt, TH1D** hdt2);
Bool_t eventLoopFillCal(Int_t nbEvt, Int_t startEv, TH1D** h1D, TH2D** h2D, TH3D** h3D);
\end{lstlisting}

Loop over all events, data written to the root tree

\begin{itemize}
	\item Int\_t $NbEvt$: 
	\item Int\_t $startEvt$: 
	\item TH1D** $hq$: 
	\item TH1D** $h1D$: 
	\item TH1D** $hdt$: 
	\item TH2D** $h2D$: 
	\item TH1D** $hdt2$: 
	\item TH3D** $h3D$: 
\end{itemize}

\subsubsection{eventLoopSyncCheck}

\begin{lstlisting}[style=customc]
Int_t eventLoopSyncCheck(Int_t nbEvt,Int_t startEv);
\end{lstlisting}

Loop over all events, data is written to the root tree.

\begin{itemize}
	\item Int\_t $NbEvt$: 
	\item Int\_t $startEvt$: 
\end{itemize}

\subsubsection{fillCalibration}

\begin{lstlisting}[style=customc]
void Unpacker::fillCalibration(const char* dir, TString list, const char* odir,const char* ofile, Int_t nEvt,Int_t n);
\end{lstlisting}

\begin{itemize}
	\item const char* $dir$: path to input file.
	\item TString $list$: list of \texttt{files.hld}.
	\item const char* $odir$: path to output directory.
	\item const char* $ofile$: path to output file.
	\item Int\_t $nEvt$: number of events.
	\item Int\_t $n$
	\begin{itemize}
		\item $n = 0$ (standard mode): just calculate the pedestals and exchande in the parameter file which is previously declared.
		\item $n = 1$ (special mode):  create pedestals and set time offsets to 0.
	\end{itemize}
\end{itemize}


\subsubsection{fillHistograms}

\begin{lstlisting}[style=customc]
void fillHistograms(const char* dir, TString list, const char* odir, const char* ofile, Int_t nEvt, Int_t n,Int_t n2);
\end{lstlisting}

\begin{itemize}
	\item const char* $dir$
	\item TString $list$
	\item const char* $odir$
	\item const char* $ofile$
	\item Int\_t $nEnv$
	\item Int\_t $n$
	\item Int\_t $n2$
	
\end{itemize}

\subsubsection{getFileHitFinderPar}

\begin{lstlisting}[style=customc]
void getFileHitFinderPar( void );
\end{lstlisting}

It gets the variable TString $fileHitFinderPar$, the name of the file with hit finder params.

\[\]

\subsubsection{getFileHitFinderParOut}

\begin{lstlisting}[style=customc]
void getFileHitFinderParOut( void );
\end{lstlisting}

It gets the variable TString $fileHitFinderParOut$, the name of the file with hit finder params.

\[\]

\subsubsection{getFileLookupPar}

\begin{lstlisting}[style=customc]
void getFileLookupPar( void );
\end{lstlisting}

It gets the variable TString $fileLookupPar$, the name of the file with lookup params.

\[\]

\subsubsection{getFileTrackFinderPar}

\begin{lstlisting}[style=customc]
void getFileTrackFinderPar( void );
\end{lstlisting}

It gets the variable TString $fileTrackFinderPar$, the name of the file with track finder params.

\[\]

\subsubsection{getpEvent}

\begin{lstlisting}[style=customc]
HldEvent* getpEvent(void);
\end{lstlisting}

It returns the pointer HldEvent* $pEvent$.

\[\]

\subsubsection{getEventLimit}

\begin{lstlisting}[style=customc]
Int_t getEventLimit()
\end{lstlisting}

It returns the Int\_t $EventLimit$.

\[\]

\subsubsection{getEventNr}

\begin{lstlisting}[style=customc]
Int_t getEventNr()
\end{lstlisting}

It returns the Int\_t $EventNr$.

\[\]

\subsubsection{HexStrToInt}

\begin{lstlisting}[style=customc]
UInt_t HexStrToInt(const char* str) {
	UInt_t t;
	std::stringstream s;
	s << std::hex << str;
	s >> t;
	return t;
 }
\end{lstlisting}

It is easy to see that \texttt{HexStrToInt} takes a const char* $str$ as argument and returns its integer value as UInt\_t $t$.

\[\]

\subsubsection{setInputFile}

\begin{lstlisting}[style=customc]
std::string setInputFile(const char* filename);
std::string setInputFile(const char* dir,const char* filename); 
\end{lstlisting}

It sets $filename$ as name of the \texttt{filename.hld} input file and returns a std::string \textit{inputFile} (\textit{wk 28.05}). If a directory $dir$ is passed as parameter, the location for \texttt{filename.hld} is changed to $dir$.

\[\]

\subsubsection{setFileHitFinderPar}

\begin{lstlisting}[style=customc]
void setFileHitFinderPar( TString fileName);
\end{lstlisting}

It sets $fileName$ to the variable TString $fileHitFinderPar$, the name of the file with hit finder params.

\[\]

\subsubsection{setFileHitFinderParOut}

\begin{lstlisting}[style=customc]
void setFileHitFinderParOut( TString fileName);
\end{lstlisting}

It sets $fileName$ to the variable TString $fileHitFinderParOut$, the name of the file with hit finder params.

\[\]

\subsubsection{setFileLookupPar}

\begin{lstlisting}[style=customc]
void setFileLookupPar( TString fileName);
\end{lstlisting}

It sets $fileName$ to the variable TString $fileLookupPar$, the name of the file with lookup params.

\[\]

\subsubsection{setFileTrackFinderPar}

\begin{lstlisting}[style=customc]
void setFileTrackFinderPar( TString fileName);
\end{lstlisting}

It sets $fileName$ to the variable TString $fileTrackFinderPar$, the name of the file with track finder params.

\[\]

\subsubsection{setpEvent}

\begin{lstlisting}[style=customc]
Bool_t setpEvent(Int_t subId);
void setpEvent(HldEvent* evt);
\end{lstlisting}

It sets $pEvent$ (the current event read from file) by reading hld file, where $subId$ is the subevent id and returns $kTRUE$. If parameter is a pointer, pEvent is set as $evt$ and doesn't returns anything.

\[\]

\subsubsection{setRootFile}

\begin{lstlisting}[style=customc]
Bool_t setRootFile(const char* filename);
\end{lstlisting}

It sets $filename$ as name to a new root output file and returns the \textsc{root} specific constant $kTRUE$.

\[\]


\subsubsection{syncCheck}

\begin{lstlisting}[style=customc]
Int_t syncCheck(const char* dir, TString file, Int_t nEvt,Int_t n);
\end{lstlisting}

\begin{itemize}
	\item const char* $dir$
	\item TString $file$
	\item Int\_t $nEnv$
	\item Int\_t $n$
	\begin{itemize}
		\item $n = 0$ (standard mode): just calculate the pedestals and exchande in the parameter file which is previously declared.
		\item $n = 1$ (special mode):  create pedestals and set time offsets to 0.
	\end{itemize}
	
\end{itemize}

\chapter{Kalman Filter}

The Kalman filter method is intended for finding the optimum estimation $\vec{r}$ of the unknown vector $\vec{r}^t$, which describes the \textsc{saeta}\footnote{Te particle is defined completely by a set of parameters $\vec{r}_k = (x_k, x_k', y_k, y_k', t_k, 1/v)^T$. We call it \textbf{SAETA} (SmAllest sET of pArameters).}, according to the measurements $\vec{m}_k$, $k = 1 ... n$ of the vector $\vec{r}^t$.

The Kalman filter starts with a certain initial approximation $\vec{r} = \vec{r}_0$ and refines the vector $\vec{r}$, consecutively adding one measurement ater the ohter. The optimum value is attained after the addition of the last measurement.

Like it is seen in table \ref{tb:planes}, the upper plane T1 has first index and its height is 1.8 m, while lower plane T4 has the latest and it is at ground. So that, since we are starting Kalman filter by the lowest plane, $\vec{r}_0 \equiv \vec{r}_4$, and $k$ indices go from $k=4$ to $k=1$

\begin{table}[h!]
\centering
\begin{tabular}{@{}ccc@{}}
\toprule
Name & Height / mm & Index \\ \midrule
T1   & 1800        & 0     \\
T2   & 900         & 1     \\
T3   & 600         & 2     \\
T4   & 0           & 3     \\ \bottomrule
\end{tabular}
\caption{The four planes of TRAGALDABAS.}
\label{tb:planes}
\end{table}

The vector $\vec{r}^t$ can change from one measurement to the next
\begin{equation}
\vec{r}^t = F_k \vec{r}^t_{k+1} + \boldsymbol\nu_k 
\label{eq:rtk}
\end{equation}
where $F_k$ is a linear operator, $\boldsymbol\nu_k$ is a process noise between $(k -1)$-th and $k$-th measurements

The measurement $\vec{m}_k$ linearly depends won $\vec{r}^t_k$:
\begin{equation}
\vec{m}_k = H_k \vec{r}^t_k + \boldsymbol\eta_k,
\label{eq:mk}
\end{equation}
where $\boldsymbol\eta_k$ is an error of the $k$-th measurement.

It is assumed that measurement errors $\boldsymbol\eta_i$ and the process noise $\boldsymbol\nu_i$ are uncorrelated, inbiased ($\langle \boldsymbol\eta_i \rangle = \langle \boldsymbol\nu_i \rangle   = \vec{0} $) and those covariance matrices $V_k$, $Q_k$ are knownw:
\begin{align}
\notag
\langle \boldsymbol\eta_i \cdot \boldsymbol\eta_i^T \rangle \equiv &\ V_i, \\
\langle \boldsymbol\nu_j \cdot \boldsymbol\nu_j^T \rangle \equiv &\ Q_j.
\label{eq:VQ}
\end{align}

The Kalman filter starts with an initial hypothetical vector $\vec{r_0}$, then for each measurement $\vec{m}_k$ a vector $\vec{r}_k$ is calculated, wwhich is the optimum estimation of the vector $\vec{r}^t$ according to the first $k$ measurements.

The conventional Kalman filter algorithm consists of four stages:
\begin{enumerate}
	\item \textsc{Initialization step:} Choose an appropieate value of the vector $\vec{r}_0$. We use an hypothetical normal one
	\begin{equation}
	\vec{r}_0 = (x_0, 0, y_0, 0, t_0, sc)^T,
	\label{eq:ro}
	\end{equation}
	where $x_0, y_0, t_0$ are the coordinates of hit in the T4 plane, $sc = 1/c$ the slowness (inverse of light celerity), and $x' = y' = 0$ the projections on $x$ and $y$ axes respectively:
	\begin{align}
	\notag
	x' &= \frac{cx}{cz} = \frac{\sin\theta \cos \phi}{\cos \theta},\\
	y' &= \frac{cy}{cz} = \frac{\sin\theta \sin \phi}{\cos \theta},
	\label{eq:xpyp}
	\end{align}
	in spherical coordinates.
	
	Its covariance matrix is set to $C_0 = I \cdot \mathrm{inf}^2$, where inf denotes a large positive number. We used:
	\begin{equation}
	C_0 = 
	\left(
	\begin{matrix}
	\mathrm{\textsc{sigx}}^2 & 0           & 0               & 0           & 0               & 0      \\
	0             & \mathrm{\textsc{vslp}} & 0               & 0           & 0               & 0       \\
	0             & 0             & \mathrm{\textsc{sigy}}^2 & 0           & 0               & 0        \\
	0             & 0             & 0             & \mathrm{\textsc{vslp}} & 0               & 0         \\
	0             & 0             & 0             & 0             & \mathrm{\textsc{sigt}}^2 & 0          \\
	0             & 0             & 0             & 0             & 0             & \mathrm{\textsc{vsln}} \\
	\end{matrix}\right),
	\end{equation}
	where \textsc{vslp} $= 0.1^2$ and \textsc{vsln} $= 0.01^2$ are the variances for slope and slowness respectively, and
	\begin{align}
	\notag
	\mathrm{\textsc{sigx}} &= \frac{1}{\sqrt{12}} \mathrm{\textsc{wcx}},\\ \notag
	\mathrm{\textsc{sigy}} &= \frac{1}{\sqrt{12}} \mathrm{\textsc{wcy}},\\
	\mathrm{\textsc{sigt}} &= 300\ \mathrm{ps},
	\label{eq:sig}
	\end{align}
	the variances for cell and time dimensions, with \textsc{wcx} $= 125$ mm and \textsc{wcy} $= 120$ mm the width of cells on $x$ and $y$ axes respectively.
	
	\item \textsc{Prediction step:} Propagate the vector from ($k+1$)-th to $k$-th plane by propagation matrix
	\begin{equation}
	F_k = 
	\left(
	\begin{matrix}
	1 & dz_k & 0 & 0    & 0 & 0    \\
	0 & 1    & 0 & 0    & 0 & 0     \\
	0 & 0    & 1 & dz_k & 0 & 0      \\
	0 & 0    & 0 & 1    & 0 & 0       \\
	0 & 0    & 0 & 0    & 1 & ks_k dz_k\\
	0 & 0    & 0 & 0    & 0 & 1         \\
	\end{matrix}\right)
	\end{equation}
	
	where $dz_k$ is the distance between $k$-th and the plane ($k + 1$)-th below
	\begin{equation}
	dz_k = z_k - z_{k+1},
	\label{eq:dz}
	\end{equation}
	and $ks_k$ is
	\begin{equation}
	ks_k = \sqrt{1 + x_k'^2 + y_k'^2},
	\label{eq:ks}
	\end{equation}
	
	so that,
	\begin{align}
	\notag
	\tilde{\vec{r}}_k &= F_k \vec{r}_{k-1},\\
	\tilde{C}_k &= F_k C_{k-1} F_k^T.
	\label{eq:pred}
	\end{align}
	
	\item \textsc{Process noise:} In contrast to the prediction step, describing deterministic changes of the vector $\vec{r}^t$ in time, the process noise describes probabilistic deviations of the vector $\vec{r}^t$.
	\begin{align}
	\notag
	\hat{\vec{r}}_k &= \tilde{\vec{r}}_k,\\
	\hat{C}_k &= \tilde{C}_k + Q_k.
	\label{eq:rn}
	\end{align}
%	\notag
%	\mathrm{[Not\ }&\mathrm{implemented\ yet]}
%	\end{align}
	
	\item \textsc{Filtration step:} At this step the state vector $\hat{\vec{r}}_k$ is updated with the new mweasurement $\vec{m}_k$ to get the optimal estimate of $\vec{r}_k$ and its covariance matrix $C_k$:
	\begin{align}
	\notag
	K_k &= \hat{C}_k H_k^T (V_k + H_k \hat{C}_k H_k^T )^{-1},\\ \notag
	\vec{r}_k &= \hat{\vec{r}}_k + K_k (\vec{m}_k - H_k \hat{\vec{r}}_k),\\ \notag
	C_k &= \hat{C}_k - K_k H_k \hat{C}_k,\\
	\chi^2_k &= \chi^2_{k+1} + (\vec{m}_k - H_k \hat{\vec{r}}_k )^T (V_k + H_k \hat{C}_k H_k^T )^{-1} (\vec{m}_k - H_k \hat{\vec{r}}_k ).
	\label{eq:K}
	\end{align}
	Here, the $k$-th measurement is
	\begin{equation}
	\vec{m}_k = (x_k, y_k, t_k)^T,
	\label{eq:m}
	\end{equation}
	and its covariance matrix
	\begin{equation}
	V_k = \left(
	\begin{matrix}
	\mathrm{\textsc{sigx}}^2 & 0                        & 0                      \\
	0                        & \mathrm{\textsc{sigy}}^2 & 0                       \\
	0                        & 0                        & \mathrm{\textsc{sigt}}^2 \\
	\end{matrix} \right).
	\label{eq:V}
	\end{equation}
	
	The matrix $H_k$ of the model is simply the identity matrix
	\begin{equation}
	H_k = 
	\left(
	\begin{matrix}
	1 & 0 & 0 & 0 & 0 & 0    \\
	0 & 0 & 1 & 0 & 0 & 0     \\
	0 & 0 & 0 & 0 & 1 & 0      \\
	\end{matrix}\right),
	\label{eq:h}
	\end{equation}
	which converts every $\hat{\vec{r}}_k = (x_k, x_k', y_k, y_k', t_k, sc)^T$ into $\vec{m_r}_k = (x_k, y_k, t_k)^T$ for comparing $\delta \vec{m}_k = \vec{m}_k - \vec{m_r}_k$ in \eqref{eq:K}.
	
\end{enumerate}

The following designations are used in Eqs. \eqref{eq:pred}-\eqref{eq:K}: $\vec{r}_{k+1}$, $C_{k+1}$ are the optimum estimation, obtained at the previous step and the error covariance matrix; the matrix $F_k$ relates the state at step $k + 1$ to the state at step $k$; \footnote{Remember that we start from the lowest plane to de highest.} $\tilde{\vec{r}}_k$, $\tilde{C}_k$ are predicted estimation of $\vec{r}^t_k$ before the process noise; $\hat{\vec{r}}_k$, $\hat{C}_k$ are predicted estimation of $\vec{r}^t_k$ after the process noise; $\vec{m}_k$, $V_k$ are the $k$-th measurement and its covariance matrix; the matrix $H_k$ is the model of measurement; the matrix $K_k$ is the so-called gain matrix; the value $\chi^2_k$ is the total $\chi^2$-deviation of the obtained estimation $\vec{r}_k$ from the measurements $\vec{m}_1, ... \vec{m}_k$.

The vector $\vec{r}_n$ obtained after the filtration of the last measurement is the desired optimal estimation of the $\vec{r}^t_n$ with the covariance matrix $C_n$.

In track fitting applications, the state vector $\vec{r}_k$ is vector of the track parameters, the prediction matrix $F_k$ dewscribes extrapolation of the track in the magnetic field from one detector to another, and the matrix of noise $Q_k$ describes the effect of multiple scattering in the material.




\end{document}























