\documentclass[a4paper]{book}
%\usepackage[subpreambles=true]{standalone}
\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
%\lstset { %
%%    language=C++,
%    backgroundcolor=\color{black!10}, % set backgroundcolor
%%    breaklines=true,
%%    frame=tlbr,
%    xleftmargin=0.5cm,
%    basicstyle=\ttfamily,
%    basicstyle=\footnotesize,% basic font setting
%}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C++,
  morekeywords={*, Int_t, UInt_t, Float_t, Bool_t, TMatrixF, TString, ClonesArray, TClonesArray}, 
  numbers=left,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  backgroundcolor=\color{yellow!10},
  identifierstyle=\color{black},
  stringstyle=\color{orange}\itfamily,
}

\lstdefinestyle{customsh}{
  language=bash,
  basicstyle=\color{green!60}\small\ttfamily,
  numbers=left,
  numberstyle=\color{black}\small\ttfamily,
  numbersep=3pt,
  frame=tb,
  showstringspaces=false,
  breaklines=true,
  columns=fullflexible,
  backgroundcolor=\color{black!85},
  linewidth=0.9\linewidth,
  xleftmargin=\parindent,  % 0.05\linewidth,
  xrightmargin=-0.1\linewidth
}

\usepackage{hyperref}
\usepackage{breakurl}

\let\vec\mathbf  % Bold vectors

\graphicspath{{images/}}

\usepackage[edges]{forest}
\definecolor{folderbg}{RGB}{124,166,198}
\definecolor{folderborder}{RGB}{110,144,169}
\newlength\Size
\setlength\Size{4pt}
\tikzset{%
  folder/.pic={%
    \filldraw [draw=folderborder, top color=folderbg!50, bottom color=folderbg] (-1.05*\Size,0.2\Size+5pt) rectangle ++(.75*\Size,-0.2\Size-5pt);
    \filldraw [draw=folderborder, top color=folderbg!50, bottom color=folderbg] (-1.15*\Size,-\Size) rectangle (1.15*\Size,\Size);
  },
  file/.pic={%
    \filldraw [draw=folderborder, top color=folderbg!5, bottom color=folderbg!10] (-\Size,.4*\Size+5pt) coordinate (a) |- (\Size,-1.2*\Size) coordinate (b) -- ++(0,1.6*\Size) coordinate (c) -- ++(-5pt,5pt) coordinate (d) -- cycle (d) |- (c) ;
  },
}
\forestset{%
  declare autowrapped toks={pic me}{},
  declare boolean register={pic root},
  pic root=0,
  pic dir tree/.style={%
    for tree={%
      folder,
      font=\ttfamily,
      grow'=0,
    },
    before typesetting nodes={%
      for tree={%
        edge label+/.option={pic me},
      },
      if pic root={
        tikz+={
          \pic at ([xshift=\Size].west) {folder};
        },
        align={l}
      }{},
    },
  },
  pic me set/.code n args=2{%
    \forestset{%
      #1/.style={%
        inner xsep=2\Size,
        pic me={pic {#2}},
      }
    }
  },
  pic me set={directory}{folder},
  pic me set={file}{file},
}



\begin{document}


\begin{titlepage}
	\par
	\centering
	\vspace{1cm}
	
\begin{minipage}[b]{0.5\linewidth}
\centering
	{\scshape\LARGE Users Manual}
	\vspace{40pt}
\end{minipage}
\begin{minipage}[b]{0.4\linewidth}
\includegraphics[height=8\baselineskip]{LogoUSC}
\end{minipage}

	\vspace{1.5cm}
	{\huge\bfseries TRAGALDABAS\\documentation\par}
	\vspace{0.25cm}
	
	\noindent\rule{\textwidth}{1pt}
	
	\vspace{0.25cm}
	{\huge\bfseries Hardware \& Software\par}
	
	\vspace{2cm}
	
	{\large\bfseries Instituto Galego de Altas Enerxías\par}
	\vspace{1cm}

%	Tutor:\par 
%	{\Large\itshape Alberto Pérez Muñuzuri\par}
%	{\small Grupo de Física no lineal \par (Dpto. Física de Partículas) \par }
%	\vspace{12pt}
%
%	Cotutor:\par 
%	{\Large\itshape David García Selfa\par}
%	{\small CESGA}\\
%	{\small (Centro de Supercomputación de Galicia)\par }
%	\vspace{12pt}
%	\vfill
%
%	Autor:\par
%	Miguel \textsc{Cruces}

	\vfill


	{\large \today\par}
\end{titlepage}


\tableofcontents


\chapter{Migración: \texttt{fpegaes2} $\rightarrow$ RaspBerry Pi \textgreater\ Nagios}

Para hacer la migración de los sensores de fpegaes2.usc.es a la Raspberry Pi 172.16.23.61, primero debemos familiarizarnos con las bases de datos RRD (Round Robin Database)\footnote{Nota: Dos o tres tablas relacionales, estructura para guardar datos con un número fijo de entradas.}. Una introducción a estas bases de datos se puede encontrar en:

\url{https://www.loriotpro.com/Products/On-line_Documentation_V5/LoriotProDoc_EN/V22-RRD_Collector_RRD_Manager/V22-A1_Introduction_RRD_EN.htm}

El funcionamiento de Nagios Graph y PNP4Nagios está en los siguientes links\footnote{Esto es lo menos crítico, porque en fpegaes2.usc.es se ve como está instalado el nagios graph y en fptrucha.usc.es está el PNP4Nagios (PNP4Nagios fuerza a tener una salida y hay que forzarlo (?).}

Nagiosgraph Manual Page:

\url{http://nagios.fm4dd.com/nagiosgraph/nagiosgraph-man.shtm}

PNP4Nagios Docs:

\url{http://docs.pnp4nagios.org/pnp-0.6/start}

(¿?) Buscar en fptrucha.usc.es los archivos python de cómo se accede a las bases de datos


\section{\texttt{fpegaes2}}

\subsection{Sensores}
Sensores en trucha \texttt{/etc/nagios/scripts/}

\subsection{Sample CGI Configuration File for Nagios 3.2.3}

\texttt{fptrucha.usc.es:/etc/nagios/cgi.cfg.fpegaes2}

\subsubsection{Main Configuration File}
This tells the CGIs where to find your main configuration file. The CGIs will read the main and host config files for any other data they might need.

\texttt{/etc/nagios/nagios.cgf}


\subsubsection{Physical HTML Path}
This is the path where the HTML files for Nagios reside.  This value is used to locate the logo images needed by the statusmap and statuswrl CGIs.

\texttt{/usr/share/nagios}


\subsubsection{URL HTML Path}
This is the path portion of the URL that corresponds to the physical location of the Nagios HTML files (as defined above). This value is used by the CGIs to locate the online documentation and graphics.  If you access the Nagios pages with an URL like
http://www.myhost.com/nagios, 
this value should be ``/nagios'' (without the quotes).

\texttt{/nagios}





\chapter{Kalman Filter}

The Kalman filter method is intended for finding the optimum estimation $\vec{r}$ of the unknown vector $\vec{r}^t$, which describes the \textsc{saeta}\footnote{Te particle is defined completely by a set of parameters $\vec{r}_k = (x_k, x_k', y_k, y_k', t_k, 1/v)^T$. We call it \textbf{SAETA} (SmAllest sET of pArameters).}, according to the measurements $\vec{m}_k$, $k = 1 ... n$ of the vector $\vec{r}^t$.

The Kalman filter starts with a certain initial approximation $\vec{r} = \vec{r}_0$ and refines the vector $\vec{r}$, consecutively adding one measurement ater the ohter. The optimum value is attained after the addition of the last measurement.

Like it is seen in table \ref{tb:planes}, the upper plane T1 has first index and its height is 1.8 m, while lower plane T4 has the latest and it is at ground. So that, since we are starting Kalman filter by the lowest plane, $\vec{r}_0 \equiv \vec{r}_4$, and $k$ indices go from $k=4$ to $k=1$

\begin{table}[h!]
\centering
\begin{tabular}{@{}ccc@{}}
\toprule
Name & Height / mm & Index \\ \midrule
T1   & 1800        & 0     \\
T2   & 900         & 1     \\
T3   & 600         & 2     \\
T4   & 0           & 3     \\ \bottomrule
\end{tabular}
\caption{The four planes of TRAGALDABAS.}
\label{tb:planes}
\end{table}

The vector $\vec{r}^t$ can change from one measurement to the next
\begin{equation}
\vec{r}^t = F_k \vec{r}^t_{k+1} + \boldsymbol\nu_k 
\label{eq:rtk}
\end{equation}
where $F_k$ is a linear operator, $\boldsymbol\nu_k$ is a process noise between $(k -1)$-th and $k$-th measurements

The measurement $\vec{m}_k$ linearly depends won $\vec{r}^t_k$:
\begin{equation}
\vec{m}_k = H_k \vec{r}^t_k + \boldsymbol\eta_k,
\label{eq:mk}
\end{equation}
where $\boldsymbol\eta_k$ is an error of the $k$-th measurement.

It is assumed that measurement errors $\boldsymbol\eta_i$ and the process noise $\boldsymbol\nu_i$ are uncorrelated, inbiased ($\langle \boldsymbol\eta_i \rangle = \langle \boldsymbol\nu_i \rangle   = \vec{0} $) and those covariance matrices $V_k$, $Q_k$ are knownw:
\begin{align}
\notag
\langle \boldsymbol\eta_i \cdot \boldsymbol\eta_i^T \rangle \equiv &\ V_i, \\
\langle \boldsymbol\nu_j \cdot \boldsymbol\nu_j^T \rangle \equiv &\ Q_j.
\label{eq:VQ}
\end{align}

The Kalman filter starts with an initial hypothetical vector $\vec{r_0}$, then for each measurement $\vec{m}_k$ a vector $\vec{r}_k$ is calculated, wwhich is the optimum estimation of the vector $\vec{r}^t$ according to the first $k$ measurements.

The conventional Kalman filter algorithm consists of four stages:
\begin{enumerate}
	\item \textsc{Initialization step:} Choose an appropieate value of the vector $\vec{r}_0$. We use an hypothetical normal one
	\begin{equation}
	\vec{r}_0 = (x_0, 0, y_0, 0, t_0, sc)^T,
	\label{eq:ro}
	\end{equation}
	where $x_0, y_0, t_0$ are the coordinates of hit in the T4 plane, $sc = 1/c$ the slowness (inverse of light celerity), and $x' = y' = 0$ the projections on $x$ and $y$ axes respectively:
	\begin{align}
	\notag
	x' &= \frac{cx}{cz} = \frac{\sin\theta \cos \phi}{\cos \theta},\\
	y' &= \frac{cy}{cz} = \frac{\sin\theta \sin \phi}{\cos \theta},
	\label{eq:xpyp}
	\end{align}
	in spherical coordinates.
	
	Its covariance matrix is set to $C_0 = I \cdot \mathrm{inf}^2$, where inf denotes a large positive number. We used:
	\begin{equation}
	C_0 = 
	\left(
	\begin{matrix}
	\mathrm{\textsc{sigx}}^2 & 0           & 0               & 0           & 0               & 0      \\
	0             & \mathrm{\textsc{vslp}} & 0               & 0           & 0               & 0       \\
	0             & 0             & \mathrm{\textsc{sigy}}^2 & 0           & 0               & 0        \\
	0             & 0             & 0             & \mathrm{\textsc{vslp}} & 0               & 0         \\
	0             & 0             & 0             & 0             & \mathrm{\textsc{sigt}}^2 & 0          \\
	0             & 0             & 0             & 0             & 0             & \mathrm{\textsc{vsln}} \\
	\end{matrix}\right),
	\end{equation}
	where \textsc{vslp} $= 0.1^2$ and \textsc{vsln} $= 0.01^2$ are the variances for slope and slowness respectively, and
	\begin{align}
	\notag
	\mathrm{\textsc{sigx}} &= \frac{1}{\sqrt{12}} \mathrm{\textsc{wcx}},\\ \notag
	\mathrm{\textsc{sigy}} &= \frac{1}{\sqrt{12}} \mathrm{\textsc{wcy}},\\
	\mathrm{\textsc{sigt}} &= 300\ \mathrm{ps},
	\label{eq:sig}
	\end{align}
	the variances for cell and time dimensions, with \textsc{wcx} $= 125$ mm and \textsc{wcy} $= 120$ mm the width of cells on $x$ and $y$ axes respectively.
	
	\item \textsc{Prediction step:} Propagate the vector from ($k+1$)-th to $k$-th plane by propagation matrix
	\begin{equation}
	F_k = 
	\left(
	\begin{matrix}
	1 & dz_k & 0 & 0    & 0 & 0    \\
	0 & 1    & 0 & 0    & 0 & 0     \\
	0 & 0    & 1 & dz_k & 0 & 0      \\
	0 & 0    & 0 & 1    & 0 & 0       \\
	0 & 0    & 0 & 0    & 1 & ks_k dz_k\\
	0 & 0    & 0 & 0    & 0 & 1         \\
	\end{matrix}\right)
	\end{equation}
	
	where $dz_k$ is the distance between $k$-th and the plane ($k + 1$)-th below
	\begin{equation}
	dz_k = z_k - z_{k+1},
	\label{eq:dz}
	\end{equation}
	and $ks_k$ is
	\begin{equation}
	ks_k = \sqrt{1 + x_k'^2 + y_k'^2},
	\label{eq:ks}
	\end{equation}
	
	so that,
	\begin{align}
	\notag
	\tilde{\vec{r}}_k &= F_k \vec{r}_{k-1},\\
	\tilde{C}_k &= F_k C_{k-1} F_k^T.
	\label{eq:pred}
	\end{align}
	
	\item \textsc{Process noise:} In contrast to the prediction step, describing deterministic changes of the vector $\vec{r}^t$ in time, the process noise describes probabilistic deviations of the vector $\vec{r}^t$.
	\begin{align}
	\notag
	\hat{\vec{r}}_k &= \tilde{\vec{r}}_k,\\
	\hat{C}_k &= \tilde{C}_k + Q_k.
	\label{eq:rn}
	\end{align}
%	\notag
%	\mathrm{[Not\ }&\mathrm{implemented\ yet]}
%	\end{align}
	
	\item \textsc{Filtration step:} At this step the state vector $\hat{\vec{r}}_k$ is updated with the new mweasurement $\vec{m}_k$ to get the optimal estimate of $\vec{r}_k$ and its covariance matrix $C_k$:
	\begin{align}
	\notag
	K_k &= \hat{C}_k H_k^T (V_k + H_k \hat{C}_k H_k^T )^{-1},\\ \notag
	\vec{r}_k &= \hat{\vec{r}}_k + K_k (\vec{m}_k - H_k \hat{\vec{r}}_k),\\ \notag
	C_k &= \hat{C}_k - K_k H_k \hat{C}_k,\\
	\chi^2_k &= \chi^2_{k+1} + (\vec{m}_k - H_k \hat{\vec{r}}_k )^T (V_k + H_k \hat{C}_k H_k^T )^{-1} (\vec{m}_k - H_k \hat{\vec{r}}_k ).
	\label{eq:K}
	\end{align}
	Here, the $k$-th measurement is
	\begin{equation}
	\vec{m}_k = (x_k, y_k, t_k)^T,
	\label{eq:m}
	\end{equation}
	and its covariance matrix
	\begin{equation}
	V_k = \left(
	\begin{matrix}
	\mathrm{\textsc{sigx}}^2 & 0                        & 0                      \\
	0                        & \mathrm{\textsc{sigy}}^2 & 0                       \\
	0                        & 0                        & \mathrm{\textsc{sigt}}^2 \\
	\end{matrix} \right).
	\label{eq:V}
	\end{equation}
	
	The matrix $H_k$ of the model is simply the identity matrix
	\begin{equation}
	H_k = 
	\left(
	\begin{matrix}
	1 & 0 & 0 & 0 & 0 & 0    \\
	0 & 0 & 1 & 0 & 0 & 0     \\
	0 & 0 & 0 & 0 & 1 & 0      \\
	\end{matrix}\right),
	\label{eq:h}
	\end{equation}
	which converts every $\hat{\vec{r}}_k = (x_k, x_k', y_k, y_k', t_k, sc)^T$ into $\vec{m_r}_k = (x_k, y_k, t_k)^T$ for comparing $\delta \vec{m}_k = \vec{m}_k - \vec{m_r}_k$ in \eqref{eq:K}.
	
\end{enumerate}

The following designations are used in Eqs. \eqref{eq:pred}-\eqref{eq:K}: $\vec{r}_{k+1}$, $C_{k+1}$ are the optimum estimation, obtained at the previous step and the error covariance matrix; the matrix $F_k$ relates the state at step $k + 1$ to the state at step $k$; \footnote{Remember that we start from the lowest plane to de highest.} $\tilde{\vec{r}}_k$, $\tilde{C}_k$ are predicted estimation of $\vec{r}^t_k$ before the process noise; $\hat{\vec{r}}_k$, $\hat{C}_k$ are predicted estimation of $\vec{r}^t_k$ after the process noise; $\vec{m}_k$, $V_k$ are the $k$-th measurement and its covariance matrix; the matrix $H_k$ is the model of measurement; the matrix $K_k$ is the so-called gain matrix; the value $\chi^2_k$ is the total $\chi^2$-deviation of the obtained estimation $\vec{r}_k$ from the measurements $\vec{m}_1, ... \vec{m}_k$.

The vector $\vec{r}_n$ obtained after the filtration of the last measurement is the desired optimal estimation of the $\vec{r}^t_n$ with the covariance matrix $C_n$.

In track fitting applications, the state vector $\vec{r}_k$ is vector of the track parameters, the prediction matrix $F_k$ dewscribes extrapolation of the track in the magnetic field from one detector to another, and the matrix of noise $Q_k$ describes the effect of multiple scattering in the material.




\end{document}























